==What is it?
has_setting is a simple extension that enables ActiveRecord models to
store settings in a separate settings table as key/value pairs where the key and value are stored as Strings.

==History
 * 0.3.8:
   * added dependent destroy option. no more zombie settings lingering around.
 * 0.3.7: 
   * Gem is now built using jeweler... after messing around and bumping versions and getting 
     strange errors, this is 'it works' feeling coming back
 * 0.3.4: 
   * Added custom formatter support. no new formatters though...
 * 0.3.1: 
   * Bug Fixed: has_many(:settings) is not added to ActiveRecord::Base but only to the classes with has_setting
   * Bug Fixed: options are not shared between classes
   * Again changed the way settings are saved. Save is now done on parent.save with an after_save callback. (like this the settings are treated as if they were attributes of the owner)
 * 0.2.x: 
   * Added :default option
   * changed way settings are saved so that unsaved parents can have settings too
   * changed nameing scheme of setting names (incompatible with versions prior 0.2.x but since nobody uses the gem i dont care :-))
 * 0.1.x: First Version


==Installation
sudo gem install simplificator-has_setting

==Setup
 * Add a migration that looks more or less like the one in <em>help/001_create_settings.rb</em>
 * Make sure the gem is loaded when your application starts

==Config
The model you want to hold settings (i.e. User, Profile, ...):
<tt>has_setting(:name_of_the_setting)</tt>
This will create the following methods for you on the owner class:
 * <tt>name_of_the_setting=(value)</tt> a standard setter
 * <tt>name_of_the_setting()</tt> a standard getter (the getter method takes an optional hash to override some options, possible values are the same as the options in has_setting())
 
<tt>has_setting(name, options)</tt> takes an optional hash of options. Following options are supported:
<em>:type</em> allows you to convert the value:
  * <em>:string</em> (default) leaves the value as it's stored in DB
  * <em>:int</em> calls to_i() on not-nil values. You'll have to deal with Exceptions if something happens here
  * <em>:float</em> calls to_f() on not-nil values. You'll have to deal with Exceptions if something happens here
<em>:default</em> allows you to specify a default value that will be returned if the setting does not exist (i.e. has never been written). Note that the default value is _ignored_ if the setting exists, no matter what the value of the setting is. The default value is returned as is, no type conversion takes place

==How it works
A polymorphic parent-child relation is created between Setting and the parent/owning class.
Getters/setters are added through meta-programming-magic. If the setter is invoked on a unsafed parent then the setting is not saved until the parent is saved, else setting is saved upon creation (i.e. first time the setter is called) / change (subsequent calls).
The getters/setters can be used in standard AR validations, Rails mass assignments/form helpers and so on.

==Gotchas
 * Values are stored as _Strings_ but not checked for type. Only requirement is it supports the to_s() method (you'll find out if it does not...)
 
 
==Example
<code>
class Foo < ActiveRecord::Base
  has_setting(:string_setting)
  has_setting(:another_string_setting, :type => :string)
  has_setting(:int_setting, :type => :int)
  has_setting(:float_setting, :type => :float, :default => 3.3)
end


foo = Foo.create

foo.string_setting
=> nil
foo.string_setting= 'a string'
foo.string_setting
=> 'a string'

foo.int_setting = 123
foo.int_setting
=> 123
foo.int_setting = '123'
foo.int_setting
=> 123

foo.float_setting
=> 3.3
foo.float_setting = nil
foo.float_setting
=> nil

</code>

   
==Todo
has_setting should stay as simple as possible... still some ideas are around:
 * Custom formatter (to convert arbitrary objects, i.e. Date/Time/DateTime...)
 * Add validation options

